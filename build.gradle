import org.apache.tools.ant.filters.ReplaceTokens
import org.asciidoctor.gradle.jvm.AsciidoctorTask
import org.codehaus.groovy.runtime.GStringImpl

import java.util.stream.Collectors

/* ========================================================
 * Project setup
 * ======================================================== */

plugins {
    id 'application'
    id 'java'
    id 'checkstyle'
    id 'codenarc'
    id 'io.quarkus'
    id 'org.asciidoctor.jvm.convert' version '3.3.2' // 4.0.2 does not compile
    id 'org.asciidoctor.jvm.pdf' version '3.3.2'     // 4.0.2 does not compile
    id 'org.owasp.dependencycheck' version '9.0.9' apply false //Not tested after 7.4.4
}

/* OWASP plugin
 *
 * If project property "enableOwasp" is flagged then
 * gradle will download required dependencies and
 * activate Gradle's OWASP plugin and its related tasks.
 *
 * Syntax: gradlew -PenableOwasp dependencyCheckAnalyze
 */
if (project.hasProperty('enableOwasp')) {
    apply plugin: 'org.owasp.dependencycheck'
}

repositories {
    mavenCentral()
    mavenLocal()
}

apply from: 'common.gradle'
apply from: 'dependencies.gradle'
apply plugin: 'maven-publish'

// global properties
ext.os = System.getProperty('os.name').toLowerCase()
ext.gradlew = os.contains('windows') ? 'gradlew.bat' : './gradlew'
ext.pluginsDir = "${rootDir}/plugins" as GStringImpl

javadoc {
    title="SunsetERP " + getCurrentGitBranch() + " API"
    failOnError = true
    options {
        source '17'
        encoding 'UTF-8'
        charSet 'UTF-8'
        // Those external Javadoc links should correspond to the actual
        // versions declared in the 'dependencies' block.
        links(
                'https://docs.oracle.com/javase/17/docs/api',
                'https://tomcat.apache.org/tomcat-9.0-doc/servletapi/',
                'http://docs.groovy-lang.org/docs/groovy-3.0.20/html/api',
                'https://commons.apache.org/proper/commons-cli/apidocs'
        )
    }
}

/*task downloadTikaParsers(type: Copy) {
    from configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.find {
        it.moduleVersion.id.group == 'org.apache.tika' && it.moduleVersion.id.name == 'tika-parsers'
    }.file
    into "${buildDir}/tmp/dependencyDownload"
}*/

// Only used for release branches
static def getCurrentGitBranch() {
    return "git branch --show-current".execute().text.trim()
}

def excludedJavaSources = [
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/cybersource/IcsPaymentServices.java',
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/orbital/OrbitalPaymentServices.java',
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/paypal/PayPalServices.java',
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/securepay/SecurePayPaymentServices.java',
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/securepay/SecurePayServiceTest.java',
        'org/sitenetsoft/sunseterp/applications/accounting/thirdparty/verisign/PayflowPro.java',
        'org/sitenetsoft/sunseterp/applications/order/thirdparty/taxware/TaxwareException.java',
        'org/sitenetsoft/sunseterp/applications/order/thirdparty/taxware/TaxwareServices.java',
        'org/sitenetsoft/sunseterp/applications/order/thirdparty/taxware/TaxwareUTL.java'
]

sourceSets {
    main {
        java {
            exclude excludedJavaSources
        }
    }
}

jar.manifest.attributes(
        'Implementation-Title': project.name,
        'Main-Class': application.mainClass,
        'Class-Path': getJarClasspath()
)

// Checks SunsetERP and OFBiz Java coding conventions.
checkstyle {
    // Defining a maximum number of "tolerated" errors ensures that
    // this number cannot increase in the future. It corresponds to
    // the sum of errors found last time it was changed after using the
    // 'checkstyle' tool present in the framework and in the official
    // plugins.
    tasks.checkstyleMain.maxErrors = 0
    // Currently there are no errors so we can show new one when they appear
    showViolations = true
}
//gitHooks {
    //hooks = ['pre-push': 'checkstyleMain codenarcMain codenarcTest']
//}

// Checks OFBiz Groovy coding conventions.
codenarc {
    setConfigFile(new File('config/codenarc/codenarc.groovy'))
    setMaxPriority1Violations(0)
    setMaxPriority2Violations(410)
    setMaxPriority3Violations(3975)
}

/* ========================================================
 * Tasks
 * ======================================================== */

// ========== Task group labels ==========
def cleanupGroup = 'Cleaning'
def docsGroup = 'Documentation'
def ofbizServer = 'SunsetERP Server'
def ofbizPlugin = 'SunsetERP Plugin'
def sysadminGroup = 'System Administration'

// ========== ERP Elements Command tasks ==========

tasks.register('SunsetERP', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'org.sitenetsoft.sunseterp.cli.Main'
    if (project.hasProperty('args')) {
        args = project.args.tokenize()
    } else {
        args = ['help']
    }
}

// ========== Documentation tasks ==========
tasks.withType(AsciidoctorTask) { task ->
    inProcess = JAVA_EXEC
    forkOptions {
        jvmArgs("--add-opens","java.base/sun.nio.ch=ALL-UNNAMED","--add-opens","java.base/java.io=ALL-UNNAMED")
    }
    outputOptions {
        // I hate we have to do this - but JRuby (asciidoctorj-pdf) and Windows don't mix well
        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            backends = ['html5']
        } else {
            backends = ['html5', 'pdf']
        }
    }
    attributes \
        'doctype': 'book',
            'revnumber': getCurrentGitBranch(),
            'experimental': '',
            'allow-uri-read': true,
            'icons': 'font',
            'sectnums': '',
            'chapter-label': '',
            'toc': 'left@',
            'toclevels': '3'
}

/*tasks.withType(AsciidoctorTask) { task ->
    inProcess = JAVA_EXEC
    forkOptions {
        jvmArgs("--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED", "--add-opens", "java.base/java.io=ALL-UNNAMED")
    }
    outputOptions {
        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            backends = ['html5']
        } else {
            backends = ['html5', 'pdf']
        }
    }
    attributes \
        'doctype': 'book',
            'revnumber': getCurrentGitBranch(),
            'experimental': '',
            'allow-uri-read': true,
            'icons': 'font',
            'sectnums': '',
            'chapter-label': 'Chapter',
            'toc': 'auto',
            'toclevels': '3'
}*/

tasks.register('deleteOfbizDocumentation') {
    doFirst { delete "${buildDir}/asciidoc/ofbiz" }
}

tasks.register('deletePluginDocumentation') {
    doFirst {
        if (!project.hasProperty('pluginId')) {
            throw new GradleException('Missing property \"pluginId\"')
        }
        if (!(activeComponents().stream().anyMatch { it.name == pluginId })) {
            throw new GradleException("Could not find plugin with id ${pluginId}")
        }
        delete "${buildDir}/asciidoc/plugins/${pluginId}"
    }
}

tasks.register('deleteAllPluginsDocumentation') {
    doFirst { delete "${buildDir}/asciidoc/plugins" }
}

tasks.register('generateReadmeFiles', AsciidoctorTask) {
    group = docsGroup
    doFirst { delete "${buildDir}/asciidoc/readme" }
    description 'Generate OFBiz README files'
    sourceDir "${rootDir}"
    // CHANGELOG.adoc should be only present in the current stable version
    sources {
        include 'README.adoc', 'CHANGELOG.adoc', 'CONTRIBUTING.adoc', 'DOCKER.adoc'
    }
    outputDir file("${buildDir}/asciidoc/readme/")
}

tasks.register('generateOfbizDocumentation', AsciidoctorTask) {
    group = docsGroup
    dependsOn deleteOfbizDocumentation
    description 'Generate OFBiz documentation manuals'

    activeComponents().each { component ->
        // Define the base path to remove
        def basePathToRemove = "/src/main/resources/org/sitenetsoft/sunseterp/"

        // Extract the relative component path by removing the base path
        def relativeComponentPath = component.absolutePath.replace("${rootDir}${basePathToRemove}", "")

        // Construct the final documentation path
        def docPath = "${rootDir}/docs/org/sitenetsoft/sunseterp/${relativeComponentPath}"

        copy {
            from "${docPath}/images/${component.name}"
            include '**/*.*'
            into "${rootDir}/docs/asciidoc/images/${component.name}"
        }
    }
    sourceDir "${rootDir}/docs/asciidoc"
    outputDir file("${buildDir}/asciidoc/ofbiz")
    doLast {
        activeComponents().each { component ->
            delete "${rootDir}/docs/asciidoc/images/${component.name}"
        }
    }
}

tasks.register('generatePluginDocumentation') {
    group = docsGroup
    dependsOn deletePluginDocumentation
    description 'Generate plugin documentation. Expects pluginId flag'
    activeComponents()
            .findAll { project.hasProperty('pluginId') && it.name == pluginId }
            .each { component ->
                def pluginAsciidoc = task "${component.name}Documentation"(type: AsciidoctorTask) {
                    def asciidocFolder = new File("${component}/src/docs/asciidoc")
                    if (asciidocFolder.exists()) {
                        copy {
                            from "${rootDir}/docs/asciidoc/images/OFBiz-Logo.svg"
                            into "${component}/src/docs/asciidoc/images"
                        }
                        sourceDir file("${component}/src/docs/asciidoc")
                        outputDir file("${buildDir}/asciidoc/plugins/${component.name}")
                        doLast { println "Documentation generated for plugin ${component.name}" }
                    } else {
                        println "No documentation found for plugin ${component.name}"
                    }
                    doLast { delete "${component}/src/docs/asciidoc/images/OFBiz-Logo.svg" }
                    mustRunAfter deletePluginDocumentation
                }
                dependsOn pluginAsciidoc
                doLast { delete "${component}/src/docs/asciidoc/images/OFBiz-Logo.svg" }
            }
}

tasks.register('generateAllPluginsDocumentation') {
    group = docsGroup
    dependsOn deleteAllPluginsDocumentation
    file("${pluginsDir}").eachDir { plugin ->
        activeComponents().each { component ->
            if (component.name == plugin.name) {
                if (subprojectExists(":plugins:${plugin.name}")) {
                    // Note: the "-" between "component.name" and "Documentation" allows to differentiate from
                    // the other inner task temporary created by the generatePluginDocumentation task
                    def pluginAsciidoc = task "${component.name}-Documentation"(type: AsciidoctorTask) {
                        def asciidocFolder = new File("${component}/src/docs/asciidoc")
                        doFirst {
                            if (asciidocFolder.exists()) {
                                copy {
                                    from "${rootDir}/docs/asciidoc/images/OFBiz-Logo.svg"
                                    into "${component}/src/docs/asciidoc/images"
                                }
                            }
                        }
                        if (asciidocFolder.exists()) {
                            sourceDir file("${component}/src/docs/asciidoc")
                            outputDir file("${buildDir}/asciidoc/plugins/${component.name}")
                            doLast { println "Documentation generated for plugin ${component.name}" }
                        }
                        mustRunAfter deleteAllPluginsDocumentation
                        doLast { delete "${component}/src/docs/asciidoc/images/OFBiz-Logo.svg" }
                    }
                    dependsOn pluginAsciidoc
                }
            }
        }
    }
}

// ========== OFBiz Plugin Management ==========
tasks.register('createPlugin') {
    group =  ofbizPlugin
    description = 'create a new plugin component based on specified templates'

    doLast {
        if (!project.hasProperty('pluginResourceName')) {
            ext.pluginResourceName = pluginId.capitalize()
        }
        if (!project.hasProperty('webappName')) {
            ext.webappName = pluginId
        }
        if (!project.hasProperty('basePermission')) {
            ext.basePermission = pluginId.toUpperCase()
        }

        def filterTokens = ['component-name'         : pluginId,
                            'component-resource-name': pluginResourceName,
                            'webapp-name'            : webappName,
                            'base-permission'        : basePermission]
        def templateDir = "${rootDir}/src/main/resources/org/sitenetsoft/sunseterp/framework/resources/templates"
        def pluginDir = "${pluginsDir}/${pluginId}"

        ['config', 'dtd', 'entitydef', 'lib', 'patches/test', 'patches/qa',
         'patches/production', 'src/main/groovy', 'minilang', 'servicedef', 'src/main/java', 'src/test/java', 'testdef',
         'widget', "webapp/${webappName}/error", "webapp/${webappName}/WEB-INF"].each {
            mkdir pluginDir + '/' + it
        }

        [[tempName: 'ofbiz-component.xml', newName: 'ofbiz-component.xml', location: ''],
         [tempName: 'build.gradle', newName: 'build.gradle', location: ''],
         [tempName: 'TypeData.xml', newName: "${pluginResourceName}TypeData.xml", location: 'data'],
         [tempName: 'SecurityPermissionSeedData.xml', newName: "${pluginResourceName}SecurityPermissionSeedData.xml", location: 'data'],
         [tempName: 'SecurityGroupDemoData.xml', newName: "${pluginResourceName}SecurityGroupDemoData.xml", location: 'data'],
         [tempName: 'DemoData.xml', newName: "${pluginResourceName}DemoData.xml", location: 'data'],
         [tempName: 'HELP.adoc', newName: 'HELP.adoc', location: ''],
         [tempName: 'README.adoc', newName: 'README.adoc', location: ''],
         [tempName: 'entitymodel.xml', newName: 'entitymodel.xml', location: 'entitydef'],
         [tempName: 'services.xml', newName: 'services.xml', location: 'servicedef'],
         [tempName: 'Tests.xml', newName: "${pluginResourceName}Tests.xml", location: 'testdef'],
         [tempName: 'UiLabels.xml', newName: "${pluginResourceName}UiLabels.xml", location: 'config'],
         [tempName: 'index.jsp', newName: 'index.jsp', location: "webapp/${webappName}"],
         [tempName: 'controller.xml', newName: 'controller.xml', location: "webapp/${webappName}/WEB-INF"],
         [tempName: 'web.xml', newName: 'web.xml', location: "webapp/${webappName}/WEB-INF"],
         [tempName: 'CommonScreens.xml', newName: 'CommonScreens.xml', location: 'widget'],
         [tempName: 'Screens.xml', newName: "${pluginResourceName}Screens.xml", location: 'widget'],
         [tempName: 'Menus.xml', newName: "${pluginResourceName}Menus.xml", location: 'widget'],
         [tempName: 'Forms.xml', newName: "${pluginResourceName}Forms.xml", location: 'widget']
        ].each { tmpl ->
            generateFileFromTemplate(templateDir + '/' + tmpl.tempName,
                    pluginDir + '/' + tmpl.location, filterTokens, tmpl.newName)
        }

        println "plugin successfully created in directory ${pluginsDir}/${pluginId}."
    }
}

tasks.register('installPlugin') {
    group = ofbizPlugin
    description = 'executes plugin install task if it exists'

    doFirst {
        if (!project.hasProperty('pluginId')) {
            throw new GradleException('Missing property \"pluginId\"')
        }
    }

    if (project.hasProperty('pluginId')) {
        activeComponents()
                .findAll { it.name == pluginId }
                .each { component ->
                    if (taskExistsInproject(":plugins:${pluginId}", 'install')) {
                        dependsOn ":plugins:${pluginId}:install"
                        doLast { println "installed plugin ${pluginId}" }
                    } else {
                        doLast { println "No install task defined for plugin ${pluginId}, nothing to do" }
                    }
                }
    }
}

tasks.register('uninstallPlugin') {
    group = ofbizPlugin
    description = 'executes plugin uninstall task if it exists'

    doFirst {
        if (!project.hasProperty('pluginId')) {
            throw new GradleException('Missing property \"pluginId\"')
        }
        if (!subprojectExists(":plugins:${pluginId}")) {
            throw new GradleException("Plugin \"${pluginId}\" does not exist")
        }
    }

    if (project.hasProperty('pluginId') && taskExistsInproject(":plugins:${pluginId}", 'uninstall')) {
        dependsOn ":plugins:${pluginId}:uninstall"
        doLast { println "uninstalled plugin ${pluginId}" }
    } else {
        doLast { println "No uninstall task defined for plugin ${pluginId}" }
    }
}

tasks.register('removePlugin') {
    group = ofbizPlugin
    description = 'Uninstall a plugin and delete its files'

    if (project.hasProperty('pluginId') && subprojectExists(":plugins:${pluginId}")) {
        dependsOn uninstallPlugin
    }

    doLast {
        if (file("${pluginsDir}/${pluginId}").exists()) {
            delete "${pluginsDir}/${pluginId}"
        } else {
            throw new GradleException("Directory not found: ${pluginsDir}/${pluginId}")
        }
    }
}

/*tasks.register('createPluginArchive', Zip) {
    from "${pluginsDir}/${pluginId}"
}*/

/*publishing {
    publications {
        ofbizPluginPublication(MavenPublication) {
            artifactId pluginId
            groupId project.hasProperty('pluginGroup') ? pluginGroup : 'org.apache.ofbiz.plugin'
            version project.hasProperty('pluginVersion') ? pluginVersion : '0.1.0-SNAPSHOT'

            artifact createPluginArchive

            pom.withXml {
                if (project.hasProperty('pluginDescription')) {
                    asNode().appendNode('description', pluginDescription)
                } else {
                    asNode().appendNode('description', "Publication of OFBiz plugin ${pluginId}")
                }
            }
        }
    }
}*/

tasks.register('createPluginArchive', Zip) {
    // Delay the configuration to execution phase
    doFirst {
        from "${pluginsDir}/${project.pluginId}"
    }
}

publishing {
    publications {
        ofbizPluginPublication(MavenPublication) {
            artifactId = project.findProperty('pluginId') ?: 'defaultPluginId'
            groupId = project.findProperty('pluginGroup') ?: 'org.apache.ofbiz.plugin'
            version = project.findProperty('pluginVersion') ?: '0.1.0-SNAPSHOT'

            artifact tasks.named('createPluginArchive').get()

            pom.withXml {
                if (project.hasProperty('pluginDescription')) {
                    asNode().appendNode('description', project.pluginDescription)
                } else {
                    asNode().appendNode('description', "Publication of OFBiz plugin ${project.pluginId}")
                }
            }
        }
    }
}

tasks.register('pushPlugin') {
    group = ofbizPlugin
    description = 'push an existing plugin to local maven repository'

    doFirst {
        if (!project.hasProperty('pluginId') || !subprojectExists(":plugins:${project.pluginId}")) {
            throw new GradleException("Plugin ${project.pluginId} does not exist or no pluginId provided, cannot publish")
        }
    }

    // Task dependencies to manage the order of execution
    dependsOn 'createPluginArchive'
    dependsOn 'publishToMavenLocal'
}

/*tasks.register('pushPlugin') {
    group = ofbizPlugin
    description = 'push an existing plugin to local maven repository'

    if (project.hasProperty('pluginId')) {
        doFirst {
            if (!subprojectExists(":plugins:${pluginId}")) {
                throw new GradleException("Plugin ${pluginId} does not exist, cannot publish")
            }
        }

        if (subprojectExists(":plugins:${pluginId}")) {
            dependsOn publishToMavenLocal
        }

    } else {
        doFirst { throw new GradleException('Missing property \"pluginId\"') }
    }
}*/

tasks.register('pullPlugin') {
    group = ofbizPlugin
    description = 'Download and install a plugin with all dependencies'

    doLast {
        if (!project.hasProperty('dependencyId')) {
            throw new GradleException('You must pass the dependencyId of the plugin')
        }

        // Connect to a remote maven repository if defined
        if (project.hasProperty('repoUrl')) {
            repositories {
                maven {
                    url repoUrl
                    if (project.hasProperty('repoUser') && project.hasProperty('repoPassword')) {
                        credentials {
                            username repoUser
                            password repoPassword
                        }
                    }
                }
            }
        }

        // download plugin and dependencies
        dependencies {
            ofbizPlugins dependencyId
        }

        // reverse the order of dependencies to install them before the plugin
        def ofbizPluginArchives = new ArrayList(configurations.ofbizPlugins.files)
        Collections.reverse(ofbizPluginArchives)

        // Extract and install plugin and dependencies
        ofbizPluginArchives.each { pluginArchive ->
            ext.pluginId = dependencyId.tokenize(':').get(1)
            println "installing plugin: ${pluginId}"
            copy {
                from zipTree(pluginArchive)
                into "${pluginsDir}/${pluginId}"
            }
            gradlewSubprocess(['installPlugin', "-PpluginId=${pluginId}"])
        }
    }
}

// ========== Clean up tasks ==========
tasks.register('cleanCatalina') {
    group = cleanupGroup
    doLast { delete "${rootDir}/runtime/catalina/work" }
}
tasks.register('cleanData') {
    group = cleanupGroup
    doLast { deleteAllInDirWithExclusions("${rootDir}/runtime/data/", ['README', 'derby.properties']) }
}
tasks.register('cleanDownloads') {
    group = cleanupGroup
    doLast {
        delete fileTree(dir: "${rootDir}/framework/base/lib", includes: ['activemq-*.jar'])
        delete fileTree(dir: "${rootDir}/framework/entity/lib/jdbc", includes: ['postgresql-*.jar'])
        delete fileTree(dir: "${rootDir}/framework/entity/lib/jdbc", includes: ['mysql-*.jar'])
    }
}
tasks.register('cleanLogs') {
    group = cleanupGroup
    doLast { deleteAllInDirWithExclusions("${rootDir}/runtime/logs/", ['README']) }
}
tasks.register('cleanOutput') {
    group = cleanupGroup
    doLast { deleteAllInDirWithExclusions("${rootDir}/runtime/output/", ['README']) }
}
tasks.register('cleanIndexes') {
    group = cleanupGroup
    doLast { deleteAllInDirWithExclusions("${rootDir}/runtime/indexes/", ['README', 'index.properties']) }
}
tasks.register('cleanTempfiles') {
    group = cleanupGroup
    doLast {
        deleteAllInDirWithExclusions("${rootDir}/runtime/tempfiles/", ['README'])
        deleteAllInDirWithExclusions("${rootDir}/runtime/tmp/", ['README'])
    }
}
tasks.register('cleanUploads') {
    group = cleanupGroup
    doLast { deleteAllInDirWithExclusions("${rootDir}/runtime/uploads/", []) }
}
tasks.register('cleanXtra') {
    group = cleanupGroup
    doLast {
        delete fileTree(dir: "${rootDir}",
                includes: ['**/.nbattrs', '**/*~', '**/.#*', '**/.DS_Store', '**/*.rej', '**/*.orig'])
    }
}

/* ========================================================
 * Test Gradle Common Functions
 * ======================================================== */

tasks.register('testXmlChildren') {
    doLast {
        def testFilePath = "${rootDir}/src/main/resources/org/sitenetsoft/sunseterp/applications/component-load.xml"
        def result = xmlChildren(testFilePath).collect(Collectors.toList())
        println "Result: $result"
    }
}

tasks.register('testSubdirs') {
    doLast {
        def testDirPath = "${rootDir}/src/main/resources/org/sitenetsoft/sunseterp/applications"
        def result = subdirs(new File(testDirPath)).collect(Collectors.toList())
        println "Result: $result"
    }
}

tasks.register('testIsComponentEnabled') {
    doLast {
        def testDirPath = "${rootDir}/src/main/resources/org/sitenetsoft/sunseterp/applications/accounting"
        def result = isComponentEnabled(new File(testDirPath))
        println "Result: $result"
    }
}

tasks.register('testActiveComponents') {
    doLast {
        def result = activeComponents()//.collect(Collectors.toList())
        println "Result: $result"
    }
}

tasks.register('testActiveResourceComponentsForClassPath') {
    doLast {
        def result = activeResourceComponentsForClassPath()
        println "Result: $result"
    }
}

tasks.register('testActive') {
    doLast {
        activeComponents().each { component ->
            println component
        }
    }
}

tasks.register('printClasspath') {
    doLast {
        println "Runtime classpath:"
        configurations.runtimeClasspath.each { println it }

        println "Compile classpath:"
        configurations.compileClasspath.each { println it }

        println "Test classpath:"
        configurations.testRuntimeClasspath.each { println it }

        println "Test compile classpath:"
        configurations.testCompileClasspath.each { println it }

        println "Resources:"
        sourceSets.main.resources.srcDirs.each { println it }
    }
}

tasks.register('getDirectoryInActiveComponentsIfExists') {
    doLast {
        def result = getDirectoryInActiveComponentsIfExists("applications")
        println "Result: $result"
    }
}

/* ========================================================
 * Helper Functions
 * ======================================================== */

def deleteAllInDirWithExclusions(dirName, exclusions) {
    ant.delete (includeEmptyDirs: 'true', verbose: 'on') {
        fileset(dir: dirName, includes: '**/*', erroronmissingdir: 'false') {
            exclusions.each { exclusion ->
                exclude name: exclusion
            }
        }
    }
}

def getDirectoryInActiveComponentsIfExists(String dirName) {
    activeComponents()
            .collect { file(it.toString() + '/' + dirName) }
            .findAll { it.exists() }
}

def generateFileFromTemplate(templateFileInFullPath, targetDirectory, filterTokens, newFileName) {
    copy {
        from (templateFileInFullPath) {
            filter ReplaceTokens, tokens: filterTokens
            rename templateFileInFullPath.tokenize('/').last(), newFileName
        }
        into targetDirectory
    }
}

def getJarClasspath() {
    def mapper = os.contains('windows') ? { '\\' + "$it" } : { "$it" }
    configurations.runtimeClasspath.collect(mapper).join(' ')
}

def subprojectExists(fullyQualifiedProject) {
    subprojects.stream()
            .anyMatch { it.path == fullyQualifiedProject.toString() }
}

def taskExistsInproject(fullyQualifiedProject, taskName) {
    subprojects.stream()
            .filter { it.path == fullyQualifiedProject.toString() }
            .flatMap { it.tasks.stream() }
            .anyMatch { it.name == taskName }
}

/*
 * Keep this task below all other clean tasks  The location of
 * declaration is important because it means that it will automatically
 * run whenever the task cleanAll executes (dependency matched by regex)
 */
def cleanTasks = tasks.findAll { it.name ==~ /^clean.+/ }
tasks.register('cleanAll') {
    dependsOn cleanTasks + clean
    description 'Execute all cleaning tasks.'
}

group 'org.sitenetsoft'
version '1.0.0-SNAPSHOT'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

test {
    systemProperty "java.util.logging.manager", "org.jboss.logmanager.LogManager"
}
compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

/*tasks.startScripts {
    doLast {
        // Alter the start script for Unix systems.
        unixScript.text =
                unixScript.text.replace('CLASSPATH=$APP_HOME/lib','CLASSPATH=$APP_HOME/config/:$APP_HOME/lib-extra/*:$APP_HOME/lib')
        // Alter the start script for Windows systems.
        windowsScript.text =
                windowsScript.text.replace('CLASSPATH=%APP_HOME%\\lib','CLASSPATH=%APP_HOME%\\conf\\;%APP_HOME%\\lib-extra\\*;%APP_HOME%\\lib')
    }
}*/

tasks.withType(CreateStartScripts).configureEach {
    doLast {
        // Generate the custom classpath
        def customClassPaths = activeResourceComponentsForClassPath()

        // Update the Unix start script
        unixScript.text = unixScript.text.replace(
                'CLASSPATH=$APP_HOME/lib',
                "CLASSPATH=${customClassPaths}:$APP_HOME/../../../resources/org/sitenetsoft/sunseterp/framework/base/config/:$APP_HOME/config/:$APP_HOME/lib-extra/*:$APP_HOME/lib"
        )

        // Update the Windows start script
        // TODO: The changed to backslashes for Windows
        windowsScript.text = windowsScript.text.replace(
                'CLASSPATH=%APP_HOME%\\lib',
                "CLASSPATH=${customClassPaths.replace(':', ';')};%APP_HOME%\\conf\\;%APP_HOME%\\lib-extra\\*;%APP_HOME%\\lib"
        )
    }
}